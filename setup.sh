#!/usr/bin/env bash

# Ubuntu Server Setup Script
# Comprehensive setup for Ubuntu 20.04 LTS+ with development tools and web server
# Author: Generated by Claude Code
# Version: 1.0.0

set -euo pipefail
trap 'echo "Error on line $LINENO"' ERR
IFS=$'\n\t'

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_VERSION="1.0.0"

# Source configuration and libraries
source "${SCRIPT_DIR}/config.sh"
source "${SCRIPT_DIR}/lib/logging.sh"
source "${SCRIPT_DIR}/lib/utils.sh"
source "${SCRIPT_DIR}/lib/validation.sh"
source "${SCRIPT_DIR}/lib/security.sh"

# Global variables
VERBOSE=false
DRY_RUN=false
SKIP_UPDATES=false
PRIMARY_USER=""
INSTALL_MODE="full"
ASSUME_YES=false

# Available installation modes
readonly VALID_MODES=("full" "nginx-only" "dev-only" "minimal")

# Module execution order
readonly MODULES=(
    "01-prerequisites"
    "02-users"
    "03-shell"
    "04-nodejs"
    "05-python"
    "06-nginx"
    "07-security"
    "08-monitoring"
    "09-optimization"
    "10-validation"
)

# Show usage information
show_usage() {
    cat << EOF
Ubuntu Server Setup Script v${SCRIPT_VERSION}

USAGE:
    ${SCRIPT_NAME} [OPTIONS]

OPTIONS:
    -v, --verbose           Enable verbose output
    -n, --dry-run          Show what would be done without executing
    -s, --skip-updates     Skip system package updates
    -u, --user USER        Specify primary application user (default: app)
    -m, --mode MODE        Installation mode: full, nginx-only, dev-only, minimal
    -y, --yes              Assume yes for all prompts (non-interactive)
    -h, --help             Show this help message

ENVIRONMENT VARIABLES:
    SETUP_LOG_LEVEL        Set logging level (DEBUG, INFO, WARN, ERROR)
    SETUP_NO_COLOR         Disable colored output (any value)
    SETUP_ASSUME_YES       Auto-confirm prompts (any value)

EXAMPLES:
    ${SCRIPT_NAME}                          # Full installation
    ${SCRIPT_NAME} --verbose --user john    # Verbose with custom user
    ${SCRIPT_NAME} --dry-run                # Preview changes
    ${SCRIPT_NAME} --mode nginx-only        # Install only Nginx stack
    ${SCRIPT_NAME} --mode dev-only          # Install only development tools

EOF
}

# Show banner
show_banner() {
    cat << "EOF"
╔═══════════════════════════════════════════════════════════════╗
║                Ubuntu Server Setup Script                     ║
║                        Version 1.0.0                          ║
║                                                               ║
║   Comprehensive Ubuntu 20.04+ server setup with security,     ║
║   development tools, and web server configuration             ║
║                                                               ║
║   https://github.com/tmattoneill/ubuntu-multipass-setup       ║
╚═══════════════════════════════════════════════════════════════╝
EOF
    echo ""
}

# Security and environment checks
security_check() {
    log_info "Performing security and environment checks..."
    
    # Check if running as root (should be run with sudo, not as root directly)
    if [[ $EUID -eq 0 ]] && [[ "${FORCE_ROOT:-}" != "true" ]] && [[ -z "${SUDO_USER:-}" ]]; then
        log_error "Do not run this script directly as root!"
        log_error "Use sudo instead: sudo ./setup.sh"
        log_info "To override this check: FORCE_ROOT=true ./setup.sh"
        exit 1
    fi
    
    # Check if in container/VM environment
    if command -v systemd-detect-virt >/dev/null 2>&1; then
        local virt_type
        virt_type=$(systemd-detect-virt 2>/dev/null || echo "none")
        if [[ "$virt_type" != "none" ]]; then
            log_info "Running in virtualized environment: $virt_type"
            
            # Special handling for containers
            if [[ "$virt_type" == "docker" ]] || [[ "$virt_type" == "lxc" ]] || [[ "$virt_type" == "systemd-nspawn" ]]; then
                log_warning "Detected container environment: $virt_type"
                log_warning "Some features may not work properly in containers"
                
                if [[ "${CONTAINER_AWARE:-}" != "true" ]]; then
                    log_info "Set CONTAINER_AWARE=true to skip this warning"
                fi
            fi
        fi
    fi
    
    # Check available disk space before starting
    local available_space
    available_space=$(df / | tail -1 | awk '{print $4}')
    local available_gb=$((available_space / 1024 / 1024))
    
    if [[ $available_gb -lt $MIN_DISK_SPACE ]]; then
        log_warning "Available disk space (${available_gb}GB) is less than recommended (${MIN_DISK_SPACE}GB)"
        if [[ "${ASSUME_YES:-}" != "true" ]]; then
            if ! prompt_user "Continue with limited disk space?"; then
                log_info "Installation cancelled due to insufficient disk space"
                exit 1
            fi
        fi
    fi
    
    # Check for conflicting services
    local conflicting_services=("apache2" "lighttpd")
    for service in "${conflicting_services[@]}"; do
        if systemctl is-active --quiet "$service" 2>/dev/null; then
            log_warning "Conflicting service '$service' is running"
            log_warning "This may cause issues with Nginx installation"
        fi
    done
    
    # Check network connectivity
    log_info "Testing network connectivity..."
    if ! ping -c 1 -W 5 8.8.8.8 >/dev/null 2>&1; then
        log_warning "Network connectivity test failed"
        log_warning "Installation may fail if internet access is required"
    fi
    
    log_success "Security and environment checks completed"
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -v|--verbose)
                VERBOSE=true
                export SETUP_LOG_LEVEL="DEBUG"
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -s|--skip-updates)
                SKIP_UPDATES=true
                shift
                ;;
            -u|--user)
                PRIMARY_USER="$2"
                shift 2
                ;;
            -m|--mode)
                INSTALL_MODE="$2"
                if [[ ! " ${VALID_MODES[*]} " =~ " ${INSTALL_MODE} " ]]; then
                    log_error "Invalid mode: ${INSTALL_MODE}"
                    log_error "Valid modes: ${VALID_MODES[*]}"
                    exit 1
                fi
                shift 2
                ;;
            -y|--yes)
                ASSUME_YES=true
                export SETUP_ASSUME_YES="1"
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
}

# Initialize script environment
initialize() {
    log_info "Initializing Ubuntu Server Setup Script v${SCRIPT_VERSION}"
    
    # Create necessary directories
    create_directory "$LOG_DIR"
    create_directory "$BACKUP_DIR"
    create_directory "$TEMP_DIR"
    
    # Set default user if not specified
    if [[ -z "$PRIMARY_USER" ]]; then
        PRIMARY_USER="$DEFAULT_APP_USER"
    fi
    
    # Export configuration for modules
    export PRIMARY_USER
    export INSTALL_MODE
    export SKIP_UPDATES
    export DRY_RUN
    export VERBOSE
    
    log_info "Configuration:"
    log_info "  Mode: $INSTALL_MODE"
    log_info "  Primary user: $PRIMARY_USER"
    log_info "  Skip updates: $SKIP_UPDATES"
    log_info "  Dry run: $DRY_RUN"
    log_info "  Verbose: $VERBOSE"
}

# Validate system prerequisites
validate_system() {
    log_info "Validating system prerequisites..."
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root (use sudo)"
        exit 1
    fi
    
    # Validate Ubuntu version
    if ! validate_ubuntu_version; then
        log_error "Unsupported Ubuntu version. This script requires Ubuntu 20.04 LTS or newer."
        exit 1
    fi
    
    # Check internet connectivity
    if ! validate_internet_connection; then
        log_error "Internet connection required for package downloads"
        exit 1
    fi
    
    # Check available disk space (warns but doesn't fail)
    validate_disk_space
    
    # Validate system architecture
    if ! validate_architecture; then
        log_error "Unsupported architecture. This script supports x86_64 and arm64."
        exit 1
    fi
    
    log_success "System validation completed successfully"
}

# Gather user information for setup
gather_user_information() {
    log_section "User Information Setup"
    
    # Skip if running in non-interactive mode
    if [[ "${ASSUME_YES:-false}" == "true" ]] || [[ ! -t 0 ]]; then
        log_info "Non-interactive mode: using default values"
        return 0
    fi
    
    log_info "Please provide some information for personalized setup:"
    echo
    
    # Primary user configuration
    echo "=== Primary User Configuration ==="
    echo "The setup will create and configure a primary user for your applications."
    echo "This user will have:"
    echo "  • Development tools (Node.js, Python, Git)"
    echo "  • Zsh with Oh My Zsh"
    echo "  • SSH key configuration"
    echo "  • Project directories and environment setup"
    echo "  • Access to deployment and system management tools"
    echo
    read -p "Enter primary username (default: ubuntu): " primary_user_input
    PRIMARY_USER="${primary_user_input:-ubuntu}"
    
    # Validate username
    if [[ ! "$PRIMARY_USER" =~ ^[a-z][-a-z0-9]*$ ]]; then
        log_error "Invalid username. Must start with lowercase letter and contain only lowercase letters, numbers, and hyphens."
        exit 1
    fi
    
    log_info "Primary user set to: $PRIMARY_USER"
    if [[ "$PRIMARY_USER" != "ubuntu" ]]; then
        log_info "Note: This will create a new user '$PRIMARY_USER' in addition to the existing 'ubuntu' user"
    fi
    echo
    
    # Git configuration
    echo "=== Git Configuration ==="
    read -p "Enter your full name for Git commits (default: $USER): " git_name
    GIT_USER_NAME="${git_name:-$USER}"
    
    read -p "Enter your email for Git commits: " git_email
    GIT_USER_EMAIL="${git_email}"
    
    # SSH Key setup
    echo
    echo "=== SSH Key Setup ==="
    echo "For secure access, we need to set up your SSH public key."
    echo "Note: If you're running this on a remote server, you'll want to paste"
    echo "      your LOCAL machine's public key to access the multipass instance."
    echo
    
    # First, always offer to paste a key (most common use case)
    read -p "Do you want to paste your SSH public key? (y/n): " paste_key
    
    if [[ "$paste_key" =~ ^[Yy] ]]; then
        echo "Please paste your SSH public key (starts with ssh-rsa, ssh-ed25519, etc.):"
        echo "Tip: On your local machine, run: cat ~/.ssh/id_rsa.pub (or id_ed25519.pub)"
        read -p "SSH Public Key: " ssh_public_key
        USER_SSH_PUBLIC_KEY="$ssh_public_key"
        
        # Validate the pasted key
        if [[ -n "$USER_SSH_PUBLIC_KEY" && "$USER_SSH_PUBLIC_KEY" =~ ^(ssh-rsa|ssh-ed25519|ssh-dss|ecdsa-sha2-) ]]; then
            local key_comment=$(echo "$USER_SSH_PUBLIC_KEY" | cut -d' ' -f3 2>/dev/null || echo "")
            echo "✅ SSH key accepted: ${key_comment:-[no comment]}"
        else
            echo "⚠️  Warning: The pasted key doesn't look like a valid SSH public key"
            read -p "Continue anyway? (y/n): " continue_anyway
            if [[ ! "$continue_anyway" =~ ^[Yy] ]]; then
                USER_SSH_PUBLIC_KEY=""
            fi
        fi
    fi
    
    # If no key was pasted, check for local keys as fallback
    if [[ -z "${USER_SSH_PUBLIC_KEY:-}" ]]; then
        echo
        echo "Checking for SSH keys on this machine..."
        
        local ssh_key_path=""
        local key_types=("id_ed25519" "id_rsa" "id_ecdsa")
        local found_keys=()
        
        # Find all available keys
        for key_type in "${key_types[@]}"; do
            if [[ -f "$HOME/.ssh/${key_type}.pub" ]]; then
                found_keys+=("${key_type}.pub")
            fi
        done
        
        if [[ ${#found_keys[@]} -gt 0 ]]; then
            echo "Found SSH public keys on this machine:"
            for i in "${!found_keys[@]}"; do
                echo "  $((i+1)). ~/.ssh/${found_keys[$i]}"
            done
            echo "  $((${#found_keys[@]}+1)). Enter a different SSH public key"
            echo "  $((${#found_keys[@]}+2)). Generate a new SSH key pair"
            echo "  $((${#found_keys[@]}+3)). Skip SSH key setup (not recommended)"
            
            read -p "Choose option (1-$((${#found_keys[@]}+3))): " key_choice
            
            if [[ "$key_choice" -ge 1 && "$key_choice" -le ${#found_keys[@]} ]]; then
                # Use selected local key
                local selected_key="${found_keys[$((key_choice-1))]}"
                ssh_key_path="$HOME/.ssh/$selected_key"
                USER_SSH_PUBLIC_KEY=$(cat "$ssh_key_path")
                echo "Using SSH key: ~/.ssh/$selected_key"
                local key_comment=$(echo "$USER_SSH_PUBLIC_KEY" | cut -d' ' -f3 2>/dev/null || echo "")
                echo "Key comment: ${key_comment:-[no comment]}"
            elif [[ "$key_choice" -eq $((${#found_keys[@]}+1)) ]]; then
                # Enter different key
                echo "Please paste your SSH public key:"
                read -p "SSH Public Key: " ssh_public_key
                USER_SSH_PUBLIC_KEY="$ssh_public_key"
            elif [[ "$key_choice" -eq $((${#found_keys[@]}+2)) ]]; then
                # Generate new key
                echo "Generating new SSH key pair on this machine..."
                mkdir -p "$HOME/.ssh"
                chmod 700 "$HOME/.ssh"
                
                local new_key_path="$HOME/.ssh/id_ed25519"
                if ssh-keygen -t ed25519 -f "$new_key_path" -C "${GIT_USER_EMAIL:-$USER@$(hostname)}" -N "" > /dev/null 2>&1; then
                    echo "✅ SSH key pair generated successfully!"
                    echo "   Private key: ${new_key_path}"
                    echo "   Public key: ${new_key_path}.pub"
                    USER_SSH_PUBLIC_KEY=$(cat "${new_key_path}.pub")
                    echo "Generated key comment: $(echo "$USER_SSH_PUBLIC_KEY" | cut -d' ' -f3)"
                else
                    echo "❌ Failed to generate SSH key"
                    USER_SSH_PUBLIC_KEY=""
                fi
            else
                # Skip SSH setup
                echo "⚠️  WARNING: Skipping SSH key setup. You may not be able to access the server!"
                echo "   You can still use 'multipass shell instance-name' to access the instance."
                USER_SSH_PUBLIC_KEY=""
            fi
        else
            echo "No SSH keys found on this machine."
            echo "Options:"
            echo "1. Enter your SSH public key manually"
            echo "2. Generate a new SSH key pair on this machine"
            echo "3. Skip SSH key setup (not recommended)"
            
            read -p "Choose option (1/2/3): " no_keys_option
            
            case "$no_keys_option" in
                1)
                    echo "Please paste your SSH public key:"
                    read -p "SSH Public Key: " ssh_public_key
                    USER_SSH_PUBLIC_KEY="$ssh_public_key"
                    ;;
                2)
                    echo "Generating new SSH key pair..."
                    mkdir -p "$HOME/.ssh"
                    chmod 700 "$HOME/.ssh"
                    
                    local new_key_path="$HOME/.ssh/id_ed25519"
                    if ssh-keygen -t ed25519 -f "$new_key_path" -C "${GIT_USER_EMAIL:-$USER@$(hostname)}" -N "" > /dev/null 2>&1; then
                        echo "✅ SSH key pair generated successfully!"
                        USER_SSH_PUBLIC_KEY=$(cat "${new_key_path}.pub")
                    else
                        echo "❌ Failed to generate SSH key"
                        USER_SSH_PUBLIC_KEY=""
                    fi
                    ;;
                3)
                    echo "⚠️  WARNING: Skipping SSH key setup."
                    USER_SSH_PUBLIC_KEY=""
                    ;;
                *)
                    echo "Invalid option. Skipping SSH key setup."
                    USER_SSH_PUBLIC_KEY=""
                    ;;
            esac
        fi
    fi
    
    # Domain/hostname setup
    echo
    echo "=== Server Configuration ==="
    read -p "Enter a hostname for this server (default: $(hostname)): " server_hostname
    SERVER_HOSTNAME="${server_hostname:-$(hostname)}"
    
    # Timezone
    read -p "Enter timezone (default: UTC): " server_timezone
    SERVER_TIMEZONE="${server_timezone:-UTC}"
    
    # Summary
    echo
    echo "=== Configuration Summary ==="
    echo "Primary User: $PRIMARY_USER"
    echo "Git Name: $GIT_USER_NAME"
    echo "Git Email: $GIT_USER_EMAIL"
    echo "SSH Key: $(echo "$USER_SSH_PUBLIC_KEY" | cut -d' ' -f1,3 2>/dev/null || echo "Provided")"
    echo "Hostname: $SERVER_HOSTNAME"
    echo "Timezone: $SERVER_TIMEZONE"
    echo
    
    read -p "Continue with this configuration? (y/n): " confirm_setup
    if [[ ! "$confirm_setup" =~ ^[Yy] ]]; then
        log_info "Setup cancelled by user"
        exit 0
    fi
    
    # Export variables for modules to use
    export PRIMARY_USER GIT_USER_NAME GIT_USER_EMAIL USER_SSH_PUBLIC_KEY SERVER_HOSTNAME SERVER_TIMEZONE
    
    log_success "User information gathered successfully"
}

# Execute a module
execute_module() {
    local module_name=$1
    local module_path="${SCRIPT_DIR}/modules/${module_name}.sh"
    
    if [[ ! -f "$module_path" ]]; then
        log_error "Module not found: $module_path"
        return 1
    fi
    
    log_info "Executing module: $module_name"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would execute: $module_path"
        return 0
    fi
    
    # Create restore point before major changes
    create_restore_point "$module_name"
    
    # Execute module with error handling
    if bash "$module_path"; then
        log_success "Module completed: $module_name"
        return 0
    else
        local exit_code=$?
        log_error "Module failed: $module_name (exit code: $exit_code)"
        
        # Offer rollback option
        if prompt_user "Do you want to attempt rollback for $module_name?"; then
            rollback_module "$module_name"
        fi
        
        return $exit_code
    fi
}

# Determine which modules to run based on installation mode
get_modules_for_mode() {
    case "$INSTALL_MODE" in
        "full")
            printf '%s\n' "${MODULES[@]}"
            ;;
        "nginx-only")
            echo "01-prerequisites"
            echo "02-users"
            echo "06-nginx"
            echo "07-security"
            echo "10-validation"
            ;;
        "dev-only")
            echo "01-prerequisites"
            echo "02-users"
            echo "03-shell"
            echo "04-nodejs"
            echo "05-python"
            echo "10-validation"
            ;;
        "minimal")
            echo "01-prerequisites"
            echo "02-users"
            echo "10-validation"
            ;;
        *)
            log_error "Unknown installation mode: $INSTALL_MODE"
            exit 1
            ;;
    esac
}

# Main execution function
main() {
    local start_time=$(date +%s)
    
    # Show banner first
    show_banner
    
    log_info "Starting Ubuntu Server Setup..."
    log_info "Timestamp: $(date)"
    log_info "Script: $SCRIPT_DIR/$SCRIPT_NAME"
    
    # Parse arguments and initialize
    parse_arguments "$@"
    
    # Perform security checks
    security_check
    
    initialize
    
    # System validation
    validate_system
    
    # Gather user information for personalized setup
    gather_user_information
    
    # Get modules to execute based on mode
    local modules_to_run=()
    while IFS= read -r module; do
        [[ -n "$module" ]] && modules_to_run+=("$module")
    done < <(get_modules_for_mode)
    
    log_info "Will execute ${#modules_to_run[@]} modules for mode: $INSTALL_MODE"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Modules that would be executed:"
        for module in "${modules_to_run[@]}"; do
            log_info "  - $module"
        done
        log_info "[DRY RUN] No changes will be made to the system"
        exit 0
    fi
    
    # Confirm before proceeding (unless --yes specified)
    if [[ "$ASSUME_YES" != "true" ]]; then
        echo
        log_warn "This script will make significant changes to your system."
        log_warn "Installation mode: $INSTALL_MODE"
        log_warn "Primary user: $PRIMARY_USER"
        echo
        if ! prompt_user "Do you want to continue?"; then
            log_info "Setup cancelled by user"
            exit 0
        fi
    fi
    
    # Execute modules
    local failed_modules=()
    local successful_modules=()
    
    for module in "${modules_to_run[@]}"; do
        if execute_module "$module"; then
            successful_modules+=("$module")
        else
            failed_modules+=("$module")
            
            # Ask if user wants to continue after failure
            if [[ "$ASSUME_YES" != "true" ]]; then
                if ! prompt_user "Continue with remaining modules?"; then
                    break
                fi
            fi
        fi
    done
    
    # Calculate execution time
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    # Generate final report
    generate_final_report "$start_time" "$end_time" "$duration" \
                         "${successful_modules[@]}" --failed "${failed_modules[@]}"
    
    # Clean up temporary files
    cleanup_temp_files
    
    # Clear the EXIT trap to avoid "Script terminated unexpectedly" message
    trap - EXIT
    
    # Exit with appropriate code
    if [[ ${#failed_modules[@]} -eq 0 ]]; then
        log_success "Setup completed successfully!"
        echo
        log_info "============================================================"
        log_info "IMPORTANT: Shell configuration changes require a new session"
        log_info "============================================================"
        log_info "To activate all changes (Zsh, Node.js, Python environments):"
        log_info "1. Exit this session: type 'exit'"
        log_info "2. Reconnect: multipass shell <instance-name>"
        log_info "3. You'll then have Zsh with Oh My Zsh and working Node.js/npm"
        echo
        exit 0
    else
        log_error "Setup completed with ${#failed_modules[@]} failed modules"
        log_info "Check logs at: $LOG_FILE"
        echo
        log_info "Note: Shell changes require exit and reconnect to take effect"
        exit 1
    fi
}

# Generate final report
generate_final_report() {
    local start_time="$1"
    local end_time="$2"
    local duration="$3"
    shift 3
    
    # Parse successful and failed modules from remaining arguments
    local successful_modules=()
    local failed_modules=()
    local parsing_failed=false
    
    for arg in "$@"; do
        if [[ "$arg" == "--failed" ]]; then
            parsing_failed=true
            continue
        fi
        
        if [[ "$parsing_failed" == "true" ]]; then
            failed_modules+=("$arg")
        else
            successful_modules+=("$arg")
        fi
    done
    
    # Display final report
    echo
    log_section "Setup Complete - Final Report"
    
    # Show timing information
    local hours=$((duration / 3600))
    local minutes=$(((duration % 3600) / 60))
    local seconds=$((duration % 60))
    
    if [[ $hours -gt 0 ]]; then
        log_info "Total execution time: ${hours}h ${minutes}m ${seconds}s"
    elif [[ $minutes -gt 0 ]]; then
        log_info "Total execution time: ${minutes}m ${seconds}s"
    else
        log_info "Total execution time: ${seconds}s"
    fi
    
    # Show successful modules
    if [[ ${#successful_modules[@]} -gt 0 ]]; then
        log_success "Successful modules (${#successful_modules[@]}):"
        for module in "${successful_modules[@]}"; do
            log_success "  ✓ $module"
        done
    fi
    
    # Show failed modules
    if [[ ${#failed_modules[@]} -gt 0 ]]; then
        log_error "Failed modules (${#failed_modules[@]}):"
        for module in "${failed_modules[@]}"; do
            log_error "  ✗ $module"
        done
    fi
    
    echo
}

# Cleanup function for script termination (only for unexpected exits)
cleanup() {
    local exit_code=$?
    log_warn "Script interrupted or terminated unexpectedly (exit code: $exit_code)"
    
    cleanup_temp_files
    
    log_info "Check logs at: $LOG_FILE"
    exit $exit_code
}

# Signal handlers
trap cleanup EXIT
trap 'log_error "Script interrupted by user"; exit 130' INT TERM

# Execute main function with all arguments
main "$@"
